"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Server = exports.SUBMIT_TRANSACTION_TIMEOUT = void 0;
var _isEmpty = _interopRequireDefault(require("lodash/isEmpty"));
var _merge = _interopRequireDefault(require("lodash/merge"));
var _stellarBase = require("stellar-base");
var _urijs = _interopRequireDefault(require("urijs"));
var _axios = _interopRequireDefault(require("./axios"));
var jsonrpc = _interopRequireWildcard(require("./jsonrpc"));
var _transaction = require("./transaction");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const SUBMIT_TRANSACTION_TIMEOUT = 60 * 1000;
exports.SUBMIT_TRANSACTION_TIMEOUT = SUBMIT_TRANSACTION_TIMEOUT;
class Server {
  constructor(serverURL) {
    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this.serverURL = (0, _urijs.default)(serverURL);
    const customHeaders = {};
    if (opts.appName) {
      customHeaders["X-App-Name"] = opts.appName;
    }
    if (opts.appVersion) {
      customHeaders["X-App-Version"] = opts.appVersion;
    }
    if (!(0, _isEmpty.default)(customHeaders)) {
      _axios.default.interceptors.request.use(config => {
        config.headers = (0, _merge.default)(customHeaders, config.headers);
        return config;
      });
    }
    if (this.serverURL.protocol() !== "https" && !opts.allowHttp) {
      throw new Error("Cannot connect to insecure soroban-rpc server");
    }
  }
  async getAccount(address) {
    const ledgerKey = _stellarBase.xdr.LedgerKey.account(new _stellarBase.xdr.LedgerKeyAccount({
      accountId: _stellarBase.xdr.PublicKey.publicKeyTypeEd25519(_stellarBase.StrKey.decodeEd25519PublicKey(address))
    })).toXDR("base64");
    const data = await jsonrpc.post(this.serverURL.toString(), "getLedgerEntries", [ledgerKey]);
    const ledgerEntries = data.entries;
    if (ledgerEntries.length === 0) {
      return Promise.reject({
        code: 404,
        message: "Ledger entry not found. Key: " + ledgerKey
      });
    }
    const ledgerEntryData = ledgerEntries[0].xdr;
    const accountEntry = _stellarBase.xdr.LedgerEntryData.fromXDR(ledgerEntryData, "base64").account();
    const {
      high,
      low
    } = accountEntry.seqNum();
    const sequence = BigInt(high) * BigInt(4294967296) + BigInt(low);
    return new _stellarBase.Account(address, sequence.toString());
  }
  async getHealth() {
    return await jsonrpc.post(this.serverURL.toString(), "getHealth");
  }
  async getContractData(contractId, key) {
    const contractKey = _stellarBase.xdr.LedgerKey.contractData(new _stellarBase.xdr.LedgerKeyContractData({
      contractId: Buffer.from(contractId, "hex"),
      key
    })).toXDR("base64");
    const getLedgerEntriesResponse = await jsonrpc.post(this.serverURL.toString(), "getLedgerEntries", [contractKey]);
    if (getLedgerEntriesResponse.entries.length === 0) {
      return Promise.reject({
        code: 404,
        message: "Ledger entry not found. Key: " + contractKey
      });
    }
    return getLedgerEntriesResponse.entries[0];
  }
  async getLedgerEntries(keys) {
    return await jsonrpc.post(this.serverURL.toString(), "getLedgerEntries", keys.map(k => k.toXDR("base64")));
  }
  async getTransaction(hash) {
    return await jsonrpc.post(this.serverURL.toString(), "getTransaction", hash);
  }
  async getEvents(request) {
    return await jsonrpc.postObject(this.serverURL.toString(), "getEvents", {
      filters: request.filters ?? [],
      pagination: {
        ...(request.cursor && {
          cursor: request.cursor
        }),
        ...(request.limit && {
          limit: request.limit
        })
      },
      ...(request.startLedger && {
        startLedger: String(request.startLedger)
      })
    });
  }
  async getNetwork() {
    return await jsonrpc.post(this.serverURL.toString(), "getNetwork");
  }
  async getLatestLedger() {
    return await jsonrpc.post(this.serverURL.toString(), "getLatestLedger");
  }
  async simulateTransaction(transaction) {
    return await jsonrpc.post(this.serverURL.toString(), "simulateTransaction", transaction.toXDR());
  }
  async prepareTransaction(transaction, networkPassphrase) {
    const [{
      passphrase
    }, simResponse] = await Promise.all([networkPassphrase ? Promise.resolve({
      passphrase: networkPassphrase
    }) : this.getNetwork(), this.simulateTransaction(transaction)]);
    if (simResponse.error) {
      throw simResponse.error;
    }
    if (!simResponse.results || simResponse.results.length < 1) {
      throw new Error("transaction simulation failed");
    }
    return (0, _transaction.assembleTransaction)(transaction, passphrase, simResponse);
  }
  async sendTransaction(transaction) {
    return await jsonrpc.post(this.serverURL.toString(), "sendTransaction", transaction.toXDR());
  }
  async requestAirdrop(address, friendbotUrl) {
    const account = typeof address === "string" ? address : address.accountId();
    friendbotUrl = friendbotUrl || (await this.getNetwork()).friendbotUrl;
    if (!friendbotUrl) {
      throw new Error("No friendbot URL configured for current network");
    }
    try {
      const response = await _axios.default.post(`${friendbotUrl}?addr=${encodeURIComponent(account)}`);
      const meta = _stellarBase.xdr.TransactionMeta.fromXDR(response.data.result_meta_xdr, "base64");
      const sequence = findCreatedAccountSequenceInTransactionMeta(meta);
      return new _stellarBase.Account(account, sequence);
    } catch (error) {
      var _error$response;
      if (((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 400) {
        var _error$response$detai;
        if ((_error$response$detai = error.response.detail) !== null && _error$response$detai !== void 0 && _error$response$detai.includes("createAccountAlreadyExist")) {
          return this.getAccount(account);
        }
      }
      throw error;
    }
  }
}
exports.Server = Server;
function findCreatedAccountSequenceInTransactionMeta(meta) {
  let operations = [];
  switch (meta.switch()) {
    case 0:
      operations = meta.operations();
      break;
    case 1:
      operations = meta.v1().operations();
      break;
    case 2:
      operations = meta.v2().operations();
      break;
    case 3:
      operations = meta.v3().operations();
      break;
    default:
      throw new Error("Unexpected transaction meta switch value");
  }
  for (const op of operations) {
    for (const c of op.changes()) {
      if (c.switch() !== _stellarBase.xdr.LedgerEntryChangeType.ledgerEntryCreated()) {
        continue;
      }
      const data = c.created().data();
      if (data.switch() !== _stellarBase.xdr.LedgerEntryType.account()) {
        continue;
      }
      const account = data.account();
      const seqNum = account.seqNum();
      return bigIntFromBytes(!seqNum.unsigned, seqNum.high, seqNum.low).toString();
    }
  }
  throw new Error("No account created in transaction");
}
function bigIntFromBytes(signed) {
  let sign = BigInt(1);
  for (var _len = arguments.length, bytes = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    bytes[_key - 1] = arguments[_key];
  }
  if (signed && bytes[0] === 0x80) {
    sign = BigInt(-1);
    bytes[0] &= 0x7f;
  }
  let b = BigInt(0);
  for (const byte of bytes) {
    b <<= BigInt(8);
    b |= BigInt(byte);
  }
  return b * sign;
}
(function (_Server) {})(Server || (exports.Server = Server = {}));