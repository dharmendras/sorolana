"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Contract = void 0;
var _operation = require("./operation");
var _xdr = _interopRequireDefault(require("./xdr"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
/**
 * Create a new Contract object.
 *
 * `Contract` represents a single contract in the Stellar network, embodying the
 * interface of the contract. See
 * [Contracts](https://soroban.stellar.org/docs/learn/interacting-with-contracts)
 * for more information about how contracts work in Stellar.
 *
 * @constructor
 *
 * @param {string} contractId - ID of the contract (ex.
 *     `000000000000000000000000000000000000000000000000000000000000000001`).
 */
// TODO: Support contract deployment, maybe?
var Contract = /*#__PURE__*/function () {
  // TODO: Figure out contract owner/id stuff here. How should we represent that?
  function Contract(contractId) {
    _classCallCheck(this, Contract);
    // TODO: Add methods based on the contractSpec (or do that elsewhere?)
    this._id = Buffer.from(contractId, 'hex');
  }

  /**
   * Returns Stellar contract ID as a hex string, ex.
   * `000000000000000000000000000000000000000000000000000000000000000001`.
   * @returns {string}
   */
  _createClass(Contract, [{
    key: "contractId",
    value: function contractId() {
      return this._id.toString('hex');
    }

    /**
     * Returns an operation that will invoke this contract call.
     *
     * @todo Allow easily building `Operation`s that invoke multiple contract
     * calls at once via this abstraction layer. For example, something like
     *
     * ```js
     * let [ a, b ] = [someId1, someId2].map(id => { new Contract(id) });
     *
     * let combinedOp = Operation.invokeHostFunctions({
     *  source: undefined, // optional
     *  functions: [
     *    a.partialCall("hello"),
     *    a.partialCall("transfer", ...),
     *    b.partialCall("increment"),
     *  ]
     * });
     * ```
     *
     * @param {string} method - name of the method to call
     * @param {...xdr.ScVal} params - arguments to pass to the function call
     * @returns {xdr.Operation} Build a InvokeHostFunctionOp operation to call the
     * contract.
     */
  }, {
    key: "call",
    value: function call(method) {
      var contractId = Buffer.from(this._id, 'hex');
      for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        params[_key - 1] = arguments[_key];
      }
      return _operation.Operation.invokeHostFunction({
        args: _xdr["default"].HostFunctionArgs.hostFunctionTypeInvokeContract([_xdr["default"].ScVal.scvBytes(contractId), _xdr["default"].ScVal.scvSymbol(method)].concat(params)),
        auth: []
      });
    }

    /**
     * Returns the read-only footprint entry necessary for any invocations to this
     * contract, for convenience when adding it to your transaction's overall
     * footprint.
     *
     * @returns {xdr.LedgerKey} the contract's executable data ledger key
     */
  }, {
    key: "getFootprint",
    value: function getFootprint() {
      var contractId = Buffer.from(this._id, 'hex');
      return _xdr["default"].LedgerKey.contractData(new _xdr["default"].LedgerKeyContractData({
        contractId: contractId,
        key: _xdr["default"].ScVal.scvLedgerKeyContractExecutable()
      }));
    }
  }]);
  return Contract;
}();
exports.Contract = Contract;